#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#*****************************************************************************
# CREATEUR : Dimo Software - Charles THIERRY
# DATE DE CREATION : 02/10/2023
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : ../../2023
# DESCRIPTION DU PROCESSUS : 
# Processus permettant la copie d'une version sur une autre pour un même cube
#*****************************************************************************

### 0.Définition des variables du monitoring
sCubeParamT	        = 'ParametrageT' ;
sCubeParamS         = 'ParametresSources' ;
sCubeParamF         = 'ParametresFonctionnels' ;
cMainProcName       = GetProcessName();
cRepertoireRacine   = GetProcessErrorFileDirectory;
cTimeStamp          = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess        = cTimeStamp | '_' | cRandomInt;
Z_DEBUT_EXE         = StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
nDebug = 1 ; 
libRejets = 1; 
sListe = '';
nNouveauSalarie = 0;

IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Admin' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

###**Définition des variables
sDimCube = '}Cubes' ; 
sCubeAttrScenario = '}ElementAttributes_Scenario' ;
sDimMois  = 'Mois' ;
sDimVersion = 'Version' ; 
sDimExercice = 'Exercice' ;
sDimScenario = 'Scenario' ;

###***Définition du périmètre source et cible
sExerciceSource = DimensionElementPrincipalName ( sDimExercice , CellgetS ( sCubeParamF ,  'ExerciceEnCours' , 'ValeurS' ) )  ;
sExerciceCible = DimensionElementPrincipalName ( sDimExercice , CellgetS ( sCubeParamF ,  'ExerciceEnCours'  , 'ValeurS' ) )  ;

sScenarioSource = DimensionElementPrincipalName ( sDimScenario , CellgetS ( sCubeParamF ,  'Scenario_Source' , 'ValeurS' ) )  ; 
sScenarioCible = DimensionElementPrincipalName ( sDimScenario , CellgetS ( sCubeParamF ,  'Scenario_Cible' , 'ValeurS' ) )  ; 

sVersionSource = 'VF' ; 
sVersionCible = 'V0'  ; 


#Création et définition du parametre permettant de connaître les version a copier et coller , il est nécessaire pour lancer le bedrock
sElementMapping1 = 'Scenario:'|sScenarioSource|'->'|sScenarioCible ; 
sElementMapping2 = 'Version:'|sVersionSource|'->'|sVersionCible|'& Scenario:'|sScenarioSource|'->'|sScenarioCible  ; 
sElementMapping3 = 'Version:'|sVersionSource|'->'|sVersionCible|'& Scenario:'|sScenarioSource|'->'|sScenarioCible |'& Exercice:'|sExerciceSource |'->'| sExerciceCible   ; 

##***Initialisation de la boucle sur la dimension }cube
i = 1 ;
nTailleBoucle = Dimsiz ( sDimCube ) ;
WHILE ( nTailleBoucle >= i ) ;

  ############## TO UPDATE ############## 
  sNomCube = DIMNM ( sDimCube , i ) ;
  #ASCIIOUTPUT ( '..\DEBUG\testvrt.txt' , snomcube ) ;
  ###**Remise à vide des variables            
  sTestScenario ='' ;
  sTestExercice ='' ;
  sTestVersion ='' ;    
    
    j = 1 ;

    ###**Définition du nombre de dimension pour le cube qu'on parcours.
    nNombreDim = CubeDimensionCountGet ( sNomCube ) ;                  
                             
    WHILE ( nNombreDim >= j ) ; 
      sDim = TABDIM ( sNomCube , j ) ; 
      ##**Test sur l'existance de la dimension Scenario                                     
      IF ( sDim @= 'Scenario') ; 
        sTestScenario = 'Oui' ;                                                                                       
      ENDIF;

      j = j + 1 ;

    END ;  

    h = 1 ;    
                             
    WHILE ( nNombreDim >= h ) ; 
      sDim = TABDIM ( sNomCube , h ) ; 
      ##Test sur l'existance de la dimension Mois                                                         
      IF ( sDim @= 'Exercice' ) ;                                                                                      
        sTestExercice = 'Oui' ; 
      ENDIF ; 
      h = h + 1 ;
    END ;  

    k = 1 ;    
                             
    WHILE ( nNombreDim >= k ) ; 
      sDim = TABDIM ( sNomCube , k ) ; 
      ##Test sur l'existance de la dimension Version                                                         
      IF ( sDim @= 'Version' ) ;                                                                                      
        sTestVersion = 'Oui' ; 
      ENDIF ; 
      k = k + 1 ;
    END ;  
    
    ############## TO UPDATE ##############
    IF ( sTestScenario @= '' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  

      #Lancement du processus bedrock
      RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , '' , 'pElementMapping' , sElementMapping1 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
      'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
      'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
    ENDIF;

    ############## TO UPDATE ##############
    IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  

      #Lancement du processus bedrock
      RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , '' , 'pElementMapping' , sElementMapping2 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
      'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
      'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
    ENDIF;

    ############## TO UPDATE ##############
    IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= 'Oui'   ) ;  

      #Lancement du processus bedrock
      RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , '' , 'pElementMapping' , sElementMapping3 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
      'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
      'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
    ENDIF;
  i = i + 1 ;
END ;
#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

#------------------------------------------------ MONITORING  ------------------------------------------------#
# Declaration variables et constantes
Z_FIN_EXE = StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
Z_PERIODE = Subst(TODAY(1),1,4) | subst(TODAY(1),6,2);
Z_STATUS = IF(GetProcessErrorFilename@='','OK','KO');
Z_TEMPS_EXECUTION = Z_FIN_EXE - Z_DEBUT_EXE;
Z_LOCAL_TIME =   today(1) | '  -  ' | subst(TIME,1,2) | 'h' | subst(TIME,4,2);
Z_UTILISATEUR = TM1User;

# Nettoyage -> CAMID("pans:u:cty@dimosoftware.com") into 'cty@dimosoftware.com'
nDebut= SCAN( 'pans:u:', Z_UTILISATEUR );
nDebutLong = LONG('pans:u:');
nStart = nDebut + nDebutLong ;
nTotal = LONG(Z_UTILISATEUR) ;
sUser = SUBST(Z_UTILISATEUR, nStart, nTotal - nStart - 1) ;

# Ecriture des informations sur le processus dans le cube ParametresSources                       
CELLPUTS( Z_STATUS , sCubeParamS , cMainProcName , 'Statut' );
CELLPUTN( Z_TEMPS_EXECUTION , sCubeParamS ,  cMainProcName ,'TempsExe');
CELLPUTS( Z_LOCAL_TIME, sCubeParamS , cMainProcName ,'DernExe');
CELLPUTS( sUser, sCubeParamS , cMainProcName ,'txt_Utilisateur' );
#------------------------------------------------ FIN - MONITORING  ------------------------------------------------#

# Récupération des alias des éléments

sExerciceSource = CellGetS ( '}ElementAttributes_Exercice', sExerciceSource, 'Description' ) ;
sScenarioSource = CellGetS ( '}ElementAttributes_Scenario' , sScenarioSource , 'FR' ) ;
sVersionSource = CellGetS ( '}ElementAttributes_Version', sVersionSource, 'FR' ) ;

sExerciceCible = CellGetS ( '}ElementAttributes_Exercice', sExerciceCible, 'Description' ) ;
sScenarioCible = CellGetS ( '}ElementAttributes_Scenario' , sScenarioCible , 'FR' ) ;
sVersionCible = CellGetS ( '}ElementAttributes_Version', sVersionCible, 'FR' ) ;

#Ecriture des informations de copie d'exercice.
CELLPUTS( 'Les données de l'|CHAR(39)|'exercice ' |sExerciceSource |', du scénario ' | sScenarioSource | ' et de la version ' | sVersionSource | ' ont été copiées sur l'|CHAR(39)| 'exercice '|sExerciceCible | ', sur le scénario ' | sScenarioCible | ' et sur la version ' | sVersionCible | '.' , sCubeParamS , cMainProcName ,'Info_Copie_Exercice' ) ;

### Màj des informations du périmètre de travail dans le cube "ParametresFonctionnels"

# Année de travail
#CellPutS ( CellgetS ( sCubeParamF ,  'ExerciceCible' , 'ValeurS' ) , sCubeParamF  ,  'ExerciceEnCours' ,  'ValeurS'  ) ;
CellPutS ( sExerciceCible , sCubeParamF  ,  'ExerciceEnCours' ,  'ValeurS'  ) ;

# Scenario de travail
#CellPutS ( CellgetS ( sCubeParamF ,  'ScenarioCible' , 'ValeurS' ) , sCubeParamF  , 'ScenarioEnCours' , 'ValeurS'  ) ;
CellPutS ( sScenarioCible, sCubeParamF  , 'ScenarioEnCours' , 'ValeurS'  ) ;

# Version de Travail
#CellPutS ( CellgetS ( sCubeParamF ,  'VersionCible' , 'ValeurS' ) , sCubeParamF  ,  'VersionEnCours' , 'ValeurS'  ) ;
CellPutS ( sVersionCible, sCubeParamF  ,  'VersionEnCours' , 'ValeurS'  ) ;

sScenarioCibleReel = CellGetS ( sCubeParamF , 'Scenario_Cible' , 'ValeurS' ) ;

# Si le scénario cible est Atterrissage, MAJ de la partie réel
# IF ( sScenarioCibleReel @= 'Atterrissage') ;
#    ExecuteProcess( 'Init_Forecast_Reel' ) ;
# ENDIF ;

## Mise à jour de la sécurité
ExecuteProcess( 'Securite_Refresh' );

 
 



#endregion