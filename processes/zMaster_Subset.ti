#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#***********************************************************************************************
# CREATEUR : 
# DATE DE CREATION : 
# DERNIERE MODIFICATION EFFECTUEE PAR :
# DATE DE DERNIERE MODIFICATION : 
# DESCRIPTION: Processus Maitre permettant de déterminer si une dimension 
# à une ou plusieurs à une ou plusieurs hiérarchie.
# Si 1 hiérarchie => Lancement processus zSubset
# Si plusieurs hiérarchie => Lancement processus zSubset_By_Level
# Attention: Ne supporte pas les hierarchie parallèle Workspace
#************************************************************************************************
#***********************************************************************************************************
#                                  Définition des cubes
#***********************************************************************************************************

sCubeParamP	             = 'ParametresSources' ;
sCubeParamT	             = 'ParametrageT' ;

#***********************************************************************************************************
#                                  Définition des constantes
#***********************************************************************************************************

cMainProcName       = GetProcessName();
cRepertoireRacine   = GetProcessErrorFileDirectory;
cTimeStamp          = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess        = cTimeStamp | '_' | cRandomInt;

IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Lanceur' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

#***********************************************************************************************************
#                                  Définition des variables
#***********************************************************************************************************

StringGlobalVariable('sProcessReturnCode');
NumericGlobalVariable('nProcessReturnCode');
nProcessReturnCode= 0;

# Pour échanger avec Process.Log.Create
NumericGlobalVariable ('zLogNumero') ; 

#***********************************************************************************************************
#                                  Initialisation des variables
#***********************************************************************************************************

zLogNumero        = 1 ;
nErrors = 0 ;

#***********************************************************************************************************
#                                  Log start time
#***********************************************************************************************************

ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'START' ,
	'pV2' , 'Creation des sous-ensembles de dimensions' ) ;

#définition des variables
sDim = pDimension;
IF (TRIM(sDim) @= '' );
  nErrors = nErrors + 1 ;
  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' ,
  'pRef' , nErrors , 'pV1' , 'Le paramètre pDim est vide' ) ;
  PROCESSERROR();
ENDIF;
#***********************************************************************************************************
#                                  Log start time
#***********************************************************************************************************

ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'START' ,
  'pV2' , 'Creation des sous-ensembles de dimensions' ) ;

#définition des variables
sDim = pDimension;
IF (TRIM(sDim) @= '' );
  nErrors = nErrors + 1 ;
  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' ,
  'pRef' , nErrors , 'pV1' , 'Le paramètre pDim est vide' ) ;
  PROCESSERROR();
ENDIF;


IF ( pDimension  @= '*' ) ; 

  # Boucle sur la dimension "}Dimensions"
  nTailleBoucle = DimSiz ( '}Dimensions' ) ;
  WHILE ( nTailleBoucle > 0 ) ;
    sDim = DimNm ( '}Dimensions' , nTailleBoucle ) ; 
    # Commentaire 
    # 1 - On fait des sous ensembles par niveaux
    # 2 - On parcourt les éléments de ces sous-ensembles pour chercher s'ils ont ou pas un parent
    # 3 - S'ils n'ont pas de parents on déduit que c'est le niveau consolidé le plus élévé d'une hiérarchie
    # 4 - On incremente une variable et si elle est sup ou egale a 2  on lance le processus de subset par niveau
    # Fin Commentaire

    ## Variable comptant le nombre d'éléments conso sans parents
    nManyLvl = 0 ;

    # récupération de la profondeur de la dimension
    nNbLvl = LevelCount( sDim , sDim ); 
    i = 1 ;
    WHILE ( i < nNbLvl ) ; 
      SubNameTempCountLvl = 'zTI_TempSubName_'| sDim | NumberToString( nNbLvl- i ) ;
      sMDX = '{TM1FILTERBYLEVEL( {TM1SUBSETALL( ['| sDim |'] )}, '| NumberToString( nNbLvl-i ) |')}' ;
      SubsetCreatebyMDX( SubNameTempCountLvl ,sMDX , 1 );
      nNbElSub = SubsetGetSize( sDim , SubNameTempCountLvl );
      j = 1;
      WHILE ( j <= nNbElSub );
        sEl = SubsetGetElementName( sDim , SubNameTempCountLvl , j ) ; 
        sParent = ELPAR ( sDim, sEl , 1 );
        IF ( sParent @= '' );
          nManyLvl = nManyLvl + 1 ;
          ## Commentaire
          # Si on a plus de 2 niveaux on sort de la boucle
          # et on lance le processus de subset by level
          # Controle effectué pour perf'
          ## Fin Commentaire
          IF ( nManyLvl >= 2 );
            Break;
          ENDIF;
        ENDIF;
        IF ( nManyLvl >= 2 );
          Break;
        ENDIF;
        j = j + 1; 
      # Fin du IF pour déterminer si les niveaux consolidés du subset ont un parent
      END;
    # Fin du IF pour création des subets de niveaux consolidés
      i = i + 1 ;
    END;

    IF ( nManyLvl < 2 );
      
    ExecuteProcess( 'zSubset' , 'pDimension' , sDim );

    ELSE;

    ExecuteProcess( 'zSubset_By_Level' , 'pDim' , sDim , 'pAllAlias' , pAllAlias ) ;
    ENDIF;

  END;

ELSE;

  # Commentaire 
  # 1 - On fait des sous ensembles par niveaux
  # 2 - On parcourt les éléments de ces sous-ensembles pour chercher s'ils ont ou pas un parent
  # 3 - S'ils n'ont pas de parents on déduit que c'est le niveau consolidé le plus élévé d'une hiérarchie
  # 4 - On incremente une variable et si elle est sup ou egale a 2  on lance le processus de subset par niveau
  # Fin Commentaire

  ## Variable comptant le nombre d'éléments conso sans parents
  nManyLvl = 0 ;

  # récupération de la profondeur de la dimension
  nNbLvl = LevelCount( sDim , sDim ); 
  i = 1 ;
  WHILE ( i < nNbLvl ) ; 
    SubNameTempCountLvl = 'zTI_TempSubName_'| sDim | NumberToString( nNbLvl- i ) ;
    sMDX = '{TM1FILTERBYLEVEL( {TM1SUBSETALL( ['| sDim |'] )}, '| NumberToString( nNbLvl-i ) |')}' ;
    SubsetCreatebyMDX( SubNameTempCountLvl ,sMDX , 1 );
    nNbElSub = SubsetGetSize( sDim , SubNameTempCountLvl );
    j = 1;
    WHILE ( j <= nNbElSub );
      sEl = SubsetGetElementName( sDim , SubNameTempCountLvl , j ) ; 
      sParent = ELPAR ( sDim, sEl , 1 );
      IF ( sParent @= '' );
        nManyLvl = nManyLvl + 1 ;
        ## Commentaire
        # Si on a plus de 2 niveaux on sort de la boucle
        # et on lance le processus de subset by level
        # Controle effectué pour perf'
        ## Fin Commentaire
        IF ( nManyLvl >= 2 );
          Break;
        ENDIF;
      ENDIF;
      IF ( nManyLvl >= 2 );
        Break;
      ENDIF;
      j = j + 1; 
    # Fin du IF pour déterminer si les niveaux consolidés du subset ont un parent
    END;
  # Fin du IF pour création des subets de niveaux consolidés
    i = i + 1 ;
  END;

  IF ( nManyLvl < 2 );
    
  ExecuteProcess( 'zSubset' , 'pDimension' , sDim );

  ELSE;

  ExecuteProcess( 'zSubset_By_Level' , 'pDim' , sDim , 'pAllAlias' , pAllAlias ) ;
  ENDIF;

ENDIF;
#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

#__________________________________________________________________________________________
#
#                                 Contrôle des erreurs                                            
#__________________________________________________________________________________________

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'END' ) ;

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , If ( GetProcessErrorFilename @= '' , 'OK' , 'KO' ) ,
   'pV1' , 'Process exécuté en ' , 'pV2' , cUtilisateur ) ;

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'BYE' ) ;
   
#__________________________________________________________________________________________
#
#                                 Création des fichiers de suivi depuis le cube Processes_Log et envoi email                         
#__________________________________________________________________________________________

   
ExecuteProcess( 'Process_Log_Export' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess ) ;
#endregion