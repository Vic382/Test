#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#*****************************************************************************
# CREATEUR : Dimo Software - VRT
# DATE DE CREATION : 14/11/2023
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : ../../2023
# DESCRIPTION DU PROCESSUS : 
# Initialisation des mois réels pour le Forecast
#*****************************************************************************

### 0.Définition des variables du monitoring
sCubeParamT	        = 'ParametrageT' ;
sCubeParamS         = 'ParametresSources' ;
sCubeParamF         = 'ParametresFonctionnels' ;
cMainProcName       = GetProcessName();
cRepertoireRacine   = GetProcessErrorFileDirectory;
cTimeStamp          = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess        = cTimeStamp | '_' | cRandomInt;
Z_DEBUT_EXE         = StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
nDebug = 1 ; 
libRejets = 1; 
sListe = '';
nNouveauSalarie = 0;

IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Admin' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

###**Définition des variables
sDimCube = '}Cubes' ; 
sCubeAttrScenario = '}ElementAttributes_Scenario' ;
sDimMois  = 'Mois' ;
sDimVersion = 'Version' ; 
sDimAnnee = 'Annee' ;
sDimScenario = 'Scenario' ;
sDimExercice = 'Exercice' ;

###***Définition du périmètre source et cible
sScenarioSource = 'Reel' ; 
sScenarioCible = DimensionElementPrincipalName ( sDimScenario , CellgetS ( sCubeParamF ,  'ScenarioEnCours' , 'ValeurS' ) )  ; 

sExerciceSource = DimensionElementPrincipalName ( sDimExercice , CellgetS ( sCubeParamF ,  'ExerciceEnCours' , 'ValeurS' ) )  ; 
sExerciceCible = DimensionElementPrincipalName ( sDimExercice , CellgetS ( sCubeParamF ,  'ExerciceEnCours' , 'ValeurS' ) )  ; 

sVersionSource = 'VF' ; 
sVersionCible = DimensionElementPrincipalName ( sDimVersion , CellgetS ( sCubeParamF ,  'VersionEnCours' , 'ValeurS' ) )  ; 

#Création et définition du parametre permettant de connaître les version a copier et coller , il est nécessaire pour lancer le bedrock
sElementMapping1 = 'Scenario:'|sScenarioSource|'->'|sScenarioCible ; 
sElementMapping2 = 'Version:'|sVersionSource|'->'|sVersionCible|'& Scenario:'|sScenarioSource|'->'|sScenarioCible  ; 
sElementMapping3 = 'Version:'|sVersionSource|'->'|sVersionCible|'& Scenario:'|sScenarioSource|'->'|sScenarioCible |'& Exercice:'|sExerciceSource |'->'| sExerciceCible   ; 


# Contrôle du scénario cible, doit être atterrissage

IF ( sScenarioCible @<> 'Atterrissage' ) ;
  ItemSkip;
ENDIF ;

##***sElementMapping permet de définir les différents éléments de mapping ( Scenario , Exercice , Version )  pour le processus "Bedrock.Cube.Data.Copy.IntraCube"
sElementMapping = 'Scenario:' | sScenarioSource | '->' | sScenarioCible ; 

#On définit la taille de notre boucle en fonction du nombre de cube
##**Remise à vide la variable sFilter
sFilter = '' ;

##***Initialisation de la boucle sur la dimension }cube
i = 1 ;
nTailleBoucle = Dimsiz ( sDimCube ) ;
WHILE ( nTailleBoucle >= i ) ;

  ############## TO UPDATE ############## 
  sNomCube = DIMNM ( sDimCube , i ) ;
  #ASCIIOUTPUT ( '..\DEBUG\testvrt.txt' , snomcube ) ;
  ###**Remise à vide des variables            
  sTestScenario ='' ;
  sTestExercice ='' ;
  sTestVersion ='' ;  
  sTestMois = '' ;
  sTestCompte = '' ;
    
    j = 1 ;

    ###**Définition du nombre de dimension pour le cube qu'on parcours.
    nNombreDim = CubeDimensionCountGet ( sNomCube ) ;                  
                             
    WHILE ( nNombreDim >= j ) ; 
      sDim = TABDIM ( sNomCube , j ) ; 
      ##**Test sur l'existance de la dimension Scenario                                     
      IF ( sDim @= 'Scenario') ; 
        sTestScenario = 'Oui' ;                                                                                       
      ENDIF;

      j = j + 1 ;

    END ;  

    h = 1 ;    
                             
    WHILE ( nNombreDim >= h ) ; 
      sDim = TABDIM ( sNomCube , h ) ; 
      ##Test sur l'existance de la dimension Mois                                                         
      IF ( sDim @= 'Exercice' ) ;                                                                                      
        sTestExercice = 'Oui' ; 
      ENDIF ; 
      h = h + 1 ;
    END ;  

    k = 1 ;    
                             
    WHILE ( nNombreDim >= k ) ; 
      sDim = TABDIM ( sNomCube , k ) ; 
      ##Test sur l'existance de la dimension Version                                                         
      IF ( sDim @= 'Version' ) ;                                                                                      
        sTestVersion = 'Oui' ; 
      ENDIF ; 
      k = k + 1 ;
    END ;  

    m = 1 ;    
                             
    WHILE ( nNombreDim >= m ) ; 
      sDim = TABDIM ( sNomCube , m ) ; 
      ##Test sur l'existance de la dimension Version                                                         
      IF ( sDim @= 'Mois' ) ;                                                                                      
        sTestMois = 'Oui' ; 
      ENDIF ; 
      m = m + 1 ;
    END ;  

    n = 1 ;    
                             
    WHILE ( nNombreDim >= n ) ; 
      sDim = TABDIM ( sNomCube , n ) ; 
      ##Test sur l'existance de la dimension Poste Budgetaire                                                         
      IF ( sDim @= 'Poste_Budgetaire' ) ;                                                                                      
        sTestCompte = 'Oui' ; 
      ENDIF ; 
      n = n + 1 ;
    END ;      
    
    IF ( sTestMois @= 'Oui' ) ;
      l = 1 ;
      nNombreElement = Dimsiz ( sDimMois ) ; 
      WHILE ( nNombreElement >= l ) ; 
      
        sMois = DIMNM(sDimMois , l );
        
        nIndexMois = DIMIX ( sDimMois , sMois ) ;
        
        sMoisPrev = CellGetS ( 'ParametresFonctionnels', 'MoisEnCours', 'ValeurS' ) ;
        nIndexMoisPrev = DIMIX ( sDimMois , sMoisPrev ) ;

        sMoisPrecPrev = CellGetS ( '}ElementAttributes_Mois', sMoisPrev , 'Mois_Precedent' ) ;
        nIndexMoisPrecPrev = DIMIX ( sDimMois , sMoisPrecPrev ) ;      
        
        IF ( ELLEV ( sDimMois , sMois ) = 0 & nIndexMois < nIndexMoisPrev ) ;
  
          sFilter = sDimMois | ':' | sMois ;  

          IF ( sTestCompte @= 'Oui' & nIndexMois = nIndexMoisPrecPrev ) ; 

            o = 1 ;
            nNombreElementCompte = Dimsiz ( 'Poste_Budgetaire' ) ;   

            WHILE ( nNombreElementCompte >= o ) ; 

              sCompte = DIMNM( 'Poste_Budgetaire', o );
              sCtrlCompte = '' ;  

              IF ( ELLEV( 'Poste_Budgetaire', sCompte ) = 0 ) ;
                sCtrlCompte = CellGetS( '}ElementAttributes_Poste_Budgetaire', sCompte , 'Import Balance Partielle' );
              ENDIF ;    


              IF ( sCtrlCompte @= 'X' ) ;
                  
                sFilterCompte = sDimMois | ':' | sMois | CHAR ( 38 ) | ' Poste_Budgetaire:' | sCompte ;
                  
                ############## TO UPDATE ##############
                IF ( sTestScenario @= '' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  
        
                  #Lancement du processus bedrock
                  RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilterCompte , 'pElementMapping' , sElementMapping1 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
                  'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
                  'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
                ENDIF;
        
                ############## TO UPDATE ##############
                IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  
        
                  #Lancement du processus bedrock
                  RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilterCompte , 'pElementMapping' , sElementMapping2 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
                  'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
                  'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
                ENDIF;
        
                ############## TO UPDATE ##############
                IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= 'Oui'   ) ;  
        
                  #Lancement du processus bedrock
                  RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilterCompte , 'pElementMapping' , sElementMapping3 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
                  'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
                  'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
                ENDIF;
              ENDIF ;
                
              o = o + 1 ;
                
            END ;    
          ELSE  ;   
            ############## TO UPDATE ##############
            IF ( sTestScenario @= '' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  
    
              #Lancement du processus bedrock
              RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilter , 'pElementMapping' , sElementMapping1 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
              'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
              'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
            ENDIF;
    
            ############## TO UPDATE ##############
            IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= ''   ) ;  
    
              #Lancement du processus bedrock
              RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilter , 'pElementMapping' , sElementMapping2 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
              'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
              'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
            ENDIF;
    
            ############## TO UPDATE ##############
            IF ( sTestScenario @= 'Oui' & sTestVersion@= 'Oui' & sTestExercice @= 'Oui'   ) ;  
    
              #Lancement du processus bedrock
              RunProcess ( 'Bedrock.Cube.Data.Copy.IntraCube' , 'pCube' , sNomCube , 'pView' , '' , 'pFilter' , sFilter , 'pElementMapping' , sElementMapping3 , 'pFactor' , 1 , 'pDimensionDelim' , '&' , 'pElementStartDelim' , ':' ,
              'pElementDelim' , '+' , 'pMappingDelimiter' , '->' , 'pZeroTarget' , 1 , 'pZeroSource' , 0 , 'pDeleteViewsAndSubsets' , 1 , 'pSuppressConsol' , 1 , 'pSuppressRules' , 1 , 'pAccumulate' , 0 ,
              'pDropAndReattachRules' , 0 , 'pCopyDataViaClonedCube' , 0 , 'pDebug' , 0 ) ;
            ENDIF;
          ENDIF ;  
              
        ENDIF ;
        
        l = l + 1 ;
      END;
    ENDIF ;    
  i = i + 1 ;
END ;

#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

#------------------------------------------------ MONITORING  ------------------------------------------------#
# Declaration variables et constantes
Z_FIN_EXE = StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
Z_PERIODE = Subst(TODAY(1),1,4) | subst(TODAY(1),6,2);
Z_STATUS = IF(GetProcessErrorFilename@='','OK','KO');
Z_TEMPS_EXECUTION = Z_FIN_EXE - Z_DEBUT_EXE;
Z_LOCAL_TIME =   today(1) | '  -  ' | subst(TIME,1,2) | 'h' | subst(TIME,4,2);
Z_UTILISATEUR = TM1User;

# Nettoyage -> CAMID("pans:u:cty@dimosoftware.com") into 'cty@dimosoftware.com'
nDebut= SCAN( 'pans:u:', Z_UTILISATEUR );
nDebutLong = LONG('pans:u:');
nStart = nDebut + nDebutLong ;
nTotal = LONG(Z_UTILISATEUR) ;
sUser = SUBST(Z_UTILISATEUR, nStart, nTotal - nStart - 1) ;

# Ecriture des informations sur le processus dans le cube ParametresSources                       
CELLPUTS( Z_STATUS , sCubeParamS , cMainProcName , 'Statut' );
CELLPUTN( Z_TEMPS_EXECUTION , sCubeParamS ,  cMainProcName ,'TempsExe');
CELLPUTS( Z_LOCAL_TIME, sCubeParamS , cMainProcName ,'DernExe');
CELLPUTS( sUser, sCubeParamS , cMainProcName ,'txt_Utilisateur' );
#------------------------------------------------ FIN - MONITORING  ------------------------------------------------#
#endregion