#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#*****************************************************************************
# CREATEUR : CTY
# DATE DE CREATION : 07/07/2023
# DESCRIPTION DU PROCESSUS : Création d'un axe temps avec mise à jour des dates
# /!\ ATTENTION /!\ Ce processus efface et reconstruit la données !
# Ce processus construit la dimension temps en fonction des données présentent dans
# le cube Param_Periode
# /!\ ATTENTION /!\ 
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : 
# MODIFICATION:
#*****************************************************************************

#***********************************************************************************************************
#                                  Définition des cubes
#***********************************************************************************************************

sCubeParamP	             = 'ParametresSources' ;
sCubeParamT	             = 'ParametrageT' ;

#***********************************************************************************************************
#                                  Définition des constantes
#***********************************************************************************************************

cMainProcName       = GetProcessName();
cRepertoireRacine   = GetProcessErrorFileDirectory;
cTimeStamp          = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess        = cTimeStamp | '_' | cRandomInt;
Z_DEBUT_EXE =  StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));

IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Admin' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

#***********************************************************************************************************
#                                  Définition des variables
#***********************************************************************************************************

sSource = '' ;
sNomFichier =  '' ;
nErrors = 0 ;
nErrorsSource = 0 ;
nDebug = 0 ; 
vFlagErreur  = 0 ;
vMessage   = '' ;
nErreurs = 0 ;

#***********************************************************************************************************
#                                  Initialisation des variables
#***********************************************************************************************************

sCubeAttrMois = '}ElementAttributes_Mois' ;
sDimMois = 'Mois' ;
sDimPeriode = 'Semaine';

sAnnee_Debut = pAnneeDebut ;
sAnnee_Fin = pAnneeFin ;

sMoisDebut = SUBST ( DimensionElementPrincipalName ( sDimMois , pMoisDebut ) , 2 , 2 ) ;
sMoisFin = SUBST ( DimensionElementPrincipalName ( sDimMois , pMoisFin ) , 2 , 2 ) ;

#**********************************************   Déclaration des variables  ***************************************************

## Remise à 0
IF ( DimensionExists ( sDimPeriode ) = 0 ) ;
  DimensionCreate ( sDimPeriode ) ;
ENDIF ;
DimensionDeleteAllElements( sDimPeriode );


sToday = TimSt( Now, '\Y-\m-\d');
sAnneeMax = pAnneeFin ;
nAnneeMax = StringToNumber(sAnneeMax) ;

sMoisFin = SUBST ( DimensionElementPrincipalName ( sDimMois , pMoisFin ) , 2 , 2 ) ;
nNbJours = CellGetN ( sCubeAttrMois , pMoisFin , 'NB_DAYS' ) ;
sNbJours = NumberToString ( nNbJours ) ;
sDateMax = sAnnee_Fin | '-' | sMoisFin | '-' | sNbJours  ;  

sAnneeDebut = pAnneeDebut ;
sMoisDebut = SUBST ( DimensionElementPrincipalName ( sDimMois , pMoisDebut ) , 2 , 2 ) ;

sDateMin = sAnneeDebut  | '-01-01' ;
nDateMinNum = DAYNO( sAnneeDebut ) ;

## Permet de traiter les semaines qui change d'exercice (ex: Se48 % Se49)
sDateDebutAnneeMin =  sAnneeDebut  | '-01-01' ;

# 21915 = jours entre 01/01/1900 et 01/01/1960
nTypeJourDebutAnneeMin =  Mod ( DayNo( sDateDebutAnneeMin ) + 21915, 7) ;

# 1 = Lundi to 7 = Dimanche
IF ( nTypeJourDebutAnneeMin = 0 ) ;
  nTypeJour = 1 ;
ELSEIF ( nTypeJourDebutAnneeMin = 1 ); 
  nTypeJour = 7 ;
ELSEIF ( nTypeJourDebutAnneeMin = 2 ); 
  nTypeJour = 6 ;
ELSEIF ( nTypeJourDebutAnneeMin = 3 ); 
  nTypeJour = 5 ;
ELSEIF ( nTypeJourDebutAnneeMin = 4); 
  nTypeJour = 4 ;
ELSEIF ( nTypeJourDebutAnneeMin = 5 ); 
  nTypeJour = 3 ;
ELSEIF ( nTypeJourDebutAnneeMin = 6 ); 
  nTypeJour = 2 ;
ENDIF;

nRatSem = nTypeJour ;
nRatSemData = nTypeJour ;
nTrouve = 0 ;
nUnique = 0 ;

## Insertion des éléments
DIMENSIONELEMENTINSERT( sDimPeriode ,'', 'Total_Semaine' ,'C');
DIMENSIONSORTORDER( sDimPeriode , 'BYINPUT' ,'ASCENDING', 'BYHIERARCHY'  ,'ASCENDING');

## Création d'un alias sous forme SXX
AttrDelete ( sDimPeriode , 'Libelle' );
AttrInsert ( sDimPeriode , '' , 'Libelle' , 'A' );

###########################################
## Creation vue source sur 'Param_Periode'
###########################################
sCubeSource = 'Param_Periode' ;

sDimSource1 = 'Annee_Calendaire';
sDimSource = 'm_Param_Periode';

sVueSource = 'zTI_' | GetProcessName();

IF( ViewExists( sCubeSource , sVueSource ) = 1 );
  ViewDestroy( sCubeSource , sVueSource );
ENDIF;
ViewCreate( sCubeSource , sVueSource , nDebug   );

# ANNEE_CALENDAIRE
IF( SubsetExists( sDimSource1 , sVueSource ) = 1 ) ;
  SubsetDestroy( sDimSource1 , sVueSource ) ;
ENDIF ;

SubsetCreate( sDimSource1 , sVueSource , nDebug  );

sElementMax = DIMIX ( sDimSource1 , sDateMax ) ;
sElementMin = DIMIX ( sDimSource1 , sDateDebutAnneeMin ) ;
WHILE( sElementMin <= sElementMax );
  sElement  =  DIMNM ( sDimSource1 , sElementMin ) ; 
  IF ( ELLEV ( sDimSource1 , sElement  ) = 0 & sElement @<> ''  ) ;
    SubsetElementInsert( sDimSource1 , sVueSource , sElement , 1 ) ;
  ENDIF;
sElementMin = sElementMin +1 ;
END ;
ViewSubsetAssign( sCubeSource , sVueSource , sDimSource1 , sVueSource );

# M_PARAM_PERIODE
IF( SubsetExists( sDimSource , sVueSource ) = 1 );
  SubsetDestroy( sDimSource , sVueSource );
ENDIF;
SubsetCreate( sDimSource , sVueSource , nDebug  );
SubsetElementInsert( sDimSource , sVueSource , 'Num_Semaine' , 1 );
ViewSubsetAssign( sCubeSource , sVueSource , sDimSource , sVueSource );

DatasourceCubeview= sVueSource ;
ViewExtractSkipZeroesSet( sCubeSource , sVueSource , 0) ;
#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****

### Metadonnées n°1 : Récupération des variables d'attributs
# Annee
nAnnee = StringToNumber (CellGetS ( sCubeSource , Annee_Calendaire, 'Annee' ))  ;
sAnnee = SUBST( Annee_Calendaire , 1 , 4 ) ;
sAnneePrec = NumberToString ( StringToNumber( sAnnee )  - 1) ;

# Exercice
sExercice = CellGetS ( sCubeSource , Annee_Calendaire, 'Exercice' )  ;
nExerciceParam = StringToNumber (SUBST(sExercice,1,4)) ;

# Jour/Semaine
sJour = SUBST( Annee_Calendaire , 9 , 2 ) ;
#sAnneeSemaine  = sAnnee| '-' | CellGetS ( sCubeSource , Annee_Calendaire , 'Num_Semaine' ) ;
sSemaineAnnee = CellGetS ( sCubeSource , Annee_Calendaire , 'Num_Semaine' ) | '-' | sExercice ; 
sNumSemaine = CellGetS ( 'Param_Periode' , Annee_Calendaire , 'Num_Semaine' ) ;

# Mois
sMois = SUBST( Annee_Calendaire , 6 , 2 ) ;
sMoisAttr = 'M' | sMois ;
nMois = ATTRN('Mois' , sMoisAttr , 'NUM_MONTH') ;
sMoisPrev = ATTRS('Mois' , sMoisAttr , 'PREVIOUS_MONTH') ;
sMoisJour = sMois | '-' | sJour ;

# MoisAnnee
sMoisAnnee = sMois| '-' | sExercice ;
sMoisAnneePrev = subst(sMoisPrev,2,2) | '-' | sExercice ;

# Trimestre/Semestre
sSemestre =   AttrS ( 'Mois' , sMoisAttr , 'SEMESTER' ) ;
sTrimestre =  AttrS (  'Mois', sMoisAttr ,'QUARTER' ) ;
sSemestreAnnee = sSemestre | '-' | sExercice ; 
sTrimestreAnnee = sTrimestre | '-' | sExercice ; 

### Metadonnées n°2 : Définition du périmètre
IF ( DAYNO( Annee_Calendaire) <  DAYNO( sDateMin ) ) ;
  nRatSem = nRatSem - 1 ;
  IF ( nRatSem <= 0 );
    nRatSem = 7 ;
  ENDIF;
  ItemSkip;
ENDIF;

# Pour ne pas créer d'élement sur l'execice max
IF ( nAnnee > nAnneeMax ) ;
  ItemSkip;
ENDIF;

# Spécifité de rattachement pour la 1ère semaine de l'année, doit etre rattaché sur sAnneeMois précedant
# Distinction des lignes par Exercice 2019_2020 différent de l'année 2020
IF(nAnnee <> nExerciceParam ) ;
   sMoisAnnee = sMoisAnneePrev ; 
ELSE ; 
   sMoisAnnee = sMois| '-' | sExercice ;
ENDIF ;

### Metadonnées n°3 : Alimentation 
# Ajouts des niveaux : Total_Semaine -> 2018 -> S1-2018 -> T1-2018 -> 2018-01 -> 2018-Se01
DIMENSIONELEMENTINSERT ( sDimPeriode ,'', sSemaineAnnee  ,'N' );
DIMENSIONELEMENTINSERT ( sDimPeriode ,'', sMoisAnnee  ,'C' );
DIMENSIONELEMENTINSERT ( sDimPeriode ,'', sTrimestreAnnee ,'C' );
DIMENSIONELEMENTINSERT ( sDimPeriode ,'', sSemestreAnnee ,'C' );
DIMENSIONELEMENTINSERT ( sDimPeriode ,'', sExercice ,'C' );

### Définition de la hierarchie
# FAUX : Rattachement semaine/mois/trimestre que sur les lundis pour eviter les doublons
# A FAIRE : Rattachement semaine/mois par majorité de jour présents sur un mois# Exemple : si semaine coupée sur Jeudi ->

# Exemple :
# Si semaine coupée sur Mecredi (ou avant) -> alors 2 jours sur le Mois et 5 jours le Mois+1 -> donc toute la semaine sur Mois
# Si semaine coupée sur Jeudi (ou après)-> alors 3 jours sur le Mois et 4 jours le Mois+1 -> donc toute la semaine sur Mois+1
# Type_jour = 3 = Mercredi dans m_Param_Periode


sJour = CellGetS( sCubeSource ,Annee_Calendaire,'Nom_Jour');
nJour = CellGetN( sCubeSource ,Annee_Calendaire,'Type_Jour');

IF(sJour @='Lundi' % sMoisJour @='01-01');
   # Niv0 : Semaine enfant de Mois_Exercice : Se01-2020_2021 -> 01-2020_2021
   DIMENSIONELEMENTCOMPONENTADD( sDimPeriode , sMoisAnnee , sSemaineAnnee ,1 );
ENDIF;

# Niv1 : Mois_Exercice enfant de Trimestre_Exercice : 01-2020_2021 -> T2-2020_2021  
DIMENSIONELEMENTCOMPONENTADD( sDimPeriode , sTrimestreAnnee , sMoisAnnee ,1 );
   
# Niv2 : Trimestre_Exercice enfant de Semestre_Exercice
DIMENSIONELEMENTCOMPONENTADD( sDimPeriode , sSemestreAnnee , sTrimestreAnnee ,1 );

# Niv3 : Trimestre_Exercice enfant de Exercice
DIMENSIONELEMENTCOMPONENTADD( sDimPeriode , sExercice , sSemestreAnnee ,1 );

# Niv4 : Exercice enfant de 'Total_Periode'
DIMENSIONELEMENTCOMPONENTADD( sDimPeriode , 'Total_Semaine' , sExercice ,1 );

# Alimentation de l'attribut libelle qui écrit la semaine sous format SXX-Exercice
# sSemaineAnnee format : Se01-2023_2024 
sNuméroSemaine = SUBST (sSemaineAnnee, 3, 2);
sLibelle = 'S' | sNuméroSemaine | '-' |sExercice ;
AttrPutS ( sLibelle , sDimPeriode , sSemaineAnnee , 'Libelle' ) ;
#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****

# Boucle par semaine sur le périmetre de temps choisi en param
IF ( DAYNO( Annee_Calendaire) <  DAYNO( sDateMin ) ) ;
  nRatSemData = nRatSemData - 1 ;
  IF ( nRatSemData <= 0 );
    nRatSemData = 7 ;
  ENDIF;
  ItemSkip;
ENDIF;
  
## Pour ne pas créer d'élement sur l'execice max.
IF ( nAnnee >  nAnneeMax ) ;
  ItemSkip;
ENDIF;

#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

#------------------------------------------------ MONITORING  ------------------------------------------------#

# Declaration variables et constantes

Z_FIN_EXE =  StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
Z_PERIODE=subst(TODAY(1),1,4) | subst(TODAY(1),6,2);

Z_STATUS=IF(GetProcessErrorFilename@='','OK','KO');
Z_TEMPS_EXECUTION= Z_FIN_EXE - Z_DEBUT_EXE;
# HEURE D'EXECUTION
nNewFormatId  =  NewDateFormatter ( 'fr-FR' , 'Europe/Paris' , 'serial' , 'medium' , 'datetime' );
Z_LOCAL_TIME = FormatDate ( NOW () , 'yyyy-MM-dd H:mm' , nNewFormatId );
Z_UTILISATEUR = TM1User;

# Ecriture des informations sur le processus dans le cube ParametresSources                       

CELLPUTS( Z_STATUS , sCubeParamP , cMainProcName , 'Statut' );
CELLPUTN( Z_TEMPS_EXECUTION , sCubeParamP ,  cMainProcName ,'TempsExe');
CELLPUTS( Z_LOCAL_TIME, sCubeParamP , cMainProcName ,'DernExe');
CELLPUTS( Z_UTILISATEUR, sCubeParamP , cMainProcName ,'txt_Utilisateur' );

#------------------------------------------------ FIN - MONITORING  ------------------------------------------------#

# Création des sous-ensemble par niv sur la dimension période 
ExecuteProcess('zSubset','pDimension', 'Periode');

#endregion