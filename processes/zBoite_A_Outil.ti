#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#*****************************************************************************
# CREATEUR : VRT/BNS
# DATE DE CREATION : 20/11/2020
# DESCRIPTION DU PROCESSUS : 
# Boite à outil des fonctions les plus utilisées
# /!\ A ADAPTER POUR UTILISATION /!\
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : 
# MODIFICATION:
#*****************************************************************************

###############################   MONITORING   #################################

#***********************************************************************************************************
#                                  Définition des cubes techniques
#***********************************************************************************************************

sCubeParamP = 'ParametresSources' ;                                                                                                                                                                                                                                                                                                                                                  
sCubeParamT = 'ParametrageT' ;

#***********************************************************************************************************
#                                  Définition des Dimensions
#***********************************************************************************************************

# Si besoin de dimensions supplémentaires


#**********************************************************************************************************
#                                  Définition des constantes
#***********************************************************************************************************

cMainProcName = GetProcessName();
cRepertoireRacine = GetProcessErrorFileDirectory;
cTimeStamp = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess = cTimeStamp | '_' | cRandomInt;

# Gestion du lancement par tâche planifié
IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Lanceur' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

cLenASCIICode = 3 ;

#**********************************************************************************************************
#                                  Définition des variables
#**********************************************************************************************************

StringGlobalVariable('sProcessReturnCode');
NumericGlobalVariable('nProcessReturnCode');

# Pour échanger avec Process.Log.Create
NumericGlobalVariable ('zLogNumero') ; 

# Pour suppression des vues et ss ensemble temporaire
nDebug = 1 ; 

#**Fichier Debug
sFichierRepDebug = CellGetS ( sCubeParamT , 'Txt_RepertoireDebug' , 'ValeurS' );
sDebug = sFichierRepDebug | 'test.txt' ;

sRepertoire = CellGetS ( sCubeParamP , 'NOM DU PROCESS' , 'Txt_RepertoireSource' ) ;
sNomFichier = CellGetS ( sCubeParamP , 'NOM DU PROCESS' , 'txt_NomFichier' ) ;

# Pour rechercher un fichier dans un repertoire
sFile  = WildCardFileSearch (  sRepertoire , 'TexteRecherche' ) ; 



#**********************************************************************************************************
#                                  Initialisation des variables
#**********************************************************************************************************

nProcessReturnCode= 0;
zLogNumero	= 1 ;

nErrors		= 0 ;

pLegacy		= 0 ;



#**********************************************************************************************************
#                                  Déterminer la taille des logs 
#***********************************************************************************************************
# Il faut remplir dans le cube Parametres_Source dans la colonne TailleLog le nombre de log maximum que nous voulons 
#Si nous ne voulons pas restreindre, il n'est pas nécessaire de mettre ce code 

nMinorErrorLogMax = CellGetN( SCubeParamP , cMainProcName , 'TailleLog') ; 
MinorErrorLogMax= nMinorErrorLogMax ; 

#**********************************************************************************************************
#                                  Log start time
#***********************************************************************************************************

# /!\ Le paramètre pV3 est structurant dans la création des logs. Ne pas variabiliser car il doit être toujours le même /!\
ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'START' ,
'pV2' , 'NOM DU PROCESS' , 'pV3' , 'FONCTION DU PROCESS' ) ;


###############################   FIN MONITORING   #################################




###############################   DEBUT DES CONTROLES (SI BESOIN ) ################
# Commentaire: ajouter controle existance du fichier source

#***********************************************************************************************************
#                                  Controles des parametres d'élément de dimension
#***********************************************************************************************************

# Dans le cas où le paramètre envoyé est un alias d'un élément de dimension, on utilise la fonction suivante pour avoir le code de l'élément
sNOMPARAMETRE = DimensionElementPrincipalName ( NomDimPARAMETRE , NOMPARAMETRE ) ;


IF ( DIMIX ( NomDimPARAMETRE , sNOMPARAMETRE ) = 0 );
  nErrors = 1;
  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' , 'pRef' , nErrors ,
  'pV1' , 'L' | CHAR(39) | 'element ' | sNOMPARAMETRE | ' n' | CHAR (39) | 'existe pas dans la dimension ' | NomDimPARAMETRE ) ;
  ProcessBreak ;
ENDIF ;


#***********************************************************************************************************
#                                  Controles des parametres chemins et fichiers
#***********************************************************************************************************

# Si chemin import vide
IF ( sRepertoire @= '' ) ;

  nErrors = 1 ;

  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' , 'pRef' , nErrors ,
  'pV1' , 'Le chemin du fichier d' | CHAR(39) | 'import est vide' ) ;
 
  ProcessBreak ;
ENDIF ;

# Si nom du fichier vide

IF ( sNomFichier @= '' ) ;

  nErrors = 1 ;

  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' , 'pRef' , nErrors ,
  'pV1' , 'Le nom du fichier d' | CHAR(39) | 'import est vide' ) ;
 
  ProcessBreak ;
ENDIF ;

## COM Controle des paramètres obligatoire de type chaine
IF ( PARAMETRE1 @= '' % PARAMETRE2 @= '' ) ;
  nErrors = 1 ;
  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'FATAL' , 'pRef' , nErrors ,
  'pV3' , 'Les paramètres obligatoires ne sont pas renseignés' ) ;
  ProcessBreak ;
ENDIF ;



###############################   FIN DES CONTROLES (SI BESOIN ) ################

###############################  ASSIGNATION DES SOURCES PROCESSUS  POUR UN FICHIER EN ENTREE ################

#**********************************************************************************************************
#                                  Assignation de la source du processus
#**********************************************************************************************************

DataSourceNameForServer    	= sCheminSourceComplet ;
DatasourceNameForClient    	= sCheminSourceComplet ;
DatasourceType		= 'CHARACTERDELIMITED' ;
#DatasourceAsciiDelimiter    	= pDelim;
#DatasourceAsciiQuoteCharacter    	= pQuote;
DatasourceASCIIDecimalSeparator    	= CHAR (44) ;
DatasourceASCIIHeaderRecords    	= 1 ;

############################### FIN POUR ASSIGNATION DES SOURCES PROCESSUS  POUR UN FICHIER EN ENTREE ################


############################### POUR CREATION D'UN SUITE NUMERIQUE ################
# Exemple : Gestion des mois 01- 02 - 03...
#Utilisable dans tout les onglets

nIncr = nIncr + 1 ;
sIncrSuivant = Fill ( '0' , 1 - Long ( NumberToString ( nIncr ) ) ) | NumberToString ( nIncr ) ;

############################### FIN POUR CREATION D'UN SUITE NUMERIQUE ################




###############################   CREATION VUE SOURCE ############################
# Cette création présente plusieurs exemples de ss ensemble par MDX les plus utilisés


###########################################
## Creation vue source
###########################################

# Declaration des variables du cube source

sCubeSource = 'NomCube' ; 
sDimSource1 = 'NomDim1' ;
sDimSource2 = 'NomDim2' ;
sDimSource3 = 'NomDim3' ;
sDimSource4 = 'NomDim4' ; 
sDimSource5 = 'NomDim5' ;
sDimSource6 = 'NomDim6' ;
sDimSource = 'NomDimMesure' ;

# Le nom de la vue du cube :
sVueSource = 'Source_vue_' | Today (0) | '_' | GetProcessName () ; 

# Le nom des sous-ensembles
sSubsetSource = 'Source_Subset_' | Today (0) | '_' | GetProcessName () ; 

## nDebug => 1 Suppresion des vues et ss ensemble temporaire / 0 on les conserves

# Destruction pour recréation de la vue
ViewDestroy ( sCubeSource , sVueSource ) ;
ViewCreate ( sCubeSource , sVueSource , nDebug ) ; 

# Création des sous-ensembles des dimensions du cube

#Exemple de selection d'un élément dans la dimension
# NomDimSource1
SubsetDestroy ( sDimSource1 , sSubsetSource ) ;
SubsetCreate ( sDimSource1 , sSubsetSource , nDebug ) ; 
SubsetElementInsert ( sDimSource1 , sSubsetSource , 'ElementDimensionSource1' , nDebug ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource1 , sSubsetSource ) ; 

# Exemple de selection de tous les niveaux 0 d'une dimension
# NomDimSource2
SubsetDestroy ( sDimSource2 , sSubsetSource ) ; 
StringMDX = '{TM1FILTERBYLEVEL ( { TM1SUBSETALL ( [ '| NomDimSource2 | ' ] ) } , 0 ) }'
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource2 , sSubsetSource ) ; 

#  Exemple de selection de tous les niveaux 0 d'une dimension excepté un élément
# NomDimSource3
sElementExcepte = 'Nom de l'element que vous souhaitez retirer' ;
SubsetDestroy ( sDimSource3 , sSubsetSource ) ; 
StringMDX = '{ EXCEPT( {TM1FILTERBYLEVEL( {TM1SUBSETALL( [ '| NomDimSource3 |' ] )}, 0)}, { ['| NomDimSource3 |'].['| sElementExcepte |'] }) }' ;
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource3 , sSubsetSource ) ; 

# Exemple de selection des enfant d'un element
# NomDimSource4
sElementParent = 'Nom du parent des elements que vous souhaitez selectionner' ;
SubsetDestroy ( sDimSource4 , sSubsetSource ) ; 
StringMDX = '{TM1DRILLDOWNMEMBER( {TM1FILTERBYPATTERN( {TM1SUBSETALL( [ '| NomDimSource4 |' ] )}, "' | sElementParent | '*")}, ALL, RECURSIVE )}' ;
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource4 , sSubsetSource ) ; 

# Exemple de selection d'element selon un attribut
# NomDimSource5
sAttribut = 'Nom de l'attribut' ;
sNomAttribut = 'Nom de l'element de l'attribut a rechercher' ;
SubsetDestroy ( sDimSource5 , sSubsetSource ) ;
StringMDX = '{FILTER( {TM1SUBSETALL( [ '| NomDimSource5 |' ] )}, [ '| NomDimSource5 |' ].[ '| sAttribut |' ] = "' | sNomAttribut | '")}' ;
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource5 , sSubsetSource ) ; 

# NomDim6
SubsetDestroy ( sDimSource6 , sSubsetSource ) ; 
StringMDX = '{TM1FILTERBYLEVEL ( { TM1SUBSETALL ( [ '| NomDimSource6 | ' ] ) } , 0 ) }'
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource6 , sSubsetSource ) ; 

# NomDimMesure
SubsetDestroy ( sDim , sSubsetSource ) ; 
StringMDX = '{TM1FILTERBYLEVEL ( { TM1SUBSETALL ( [ '| NomDimSource | ' ] ) } , 0 ) }'
SubsetCreateByMDX ( sSubsetSource , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeSource , sVueSource , sDimSource , sSubsetSource ) ; 

#### Uniquement pour une vue source ####
ViewExtractSkipCalcsSet( sCubeSource , sVueSource , 0 );
ViewExtractSkipZeroesSet( sCubeSource , sVueSource , 0 );
ViewExtractSkipRuleValuesSet( sCubeSource , sVueSource , 0 );

#Définition de la source
DataSourceNameForServer = sCubeSource ;
DatasourceCubeView = sVueSource ;



###############################  FIN CREATION VUE SOURCE ############################


###############################  DEBUT CREATION VUE ZERO ############################

###########################################
## Creation vue zero sur MON CUBE
###########################################


# Le nom de la vue du cube :
sVueZero = 'RAZ_vue_' | Today (0) | '_' | GetProcessName () ; 

# Le nom des sous-ensembles
sSubsetZero = 'RAZ_Subset_' | Today (0) | '_' | GetProcessName () ; 

## nDebug => 1 Suppresion des vues et ss ensemble temporaire / 0 on les conserves

# Declaration des variables du cube cible
sCubeCible = 'NomCube' ;
sDimCible1 = 'NomDim1' ;
sDimCible2 = 'NomDim2' ;
sDimCible3 = 'NomDim3' ;
sDimCible4 = 'NomDim4' ;
sDimCible5 = 'NomDim5' ;
sDimCible6 = 'NomDim6' ;
sDimCible = 'NomDim' ;

# Désactivation du logging -> Réactivation en Epilog
vLogChanges = CubeGetLogChanges( sCubeCible );
CubeSetLogChanges( sCubeCible , 0 );

IF( ViewExists( sCubeCible, sVueZero ) = 1 );
  ViewDestroy( sCubeCible, sVueZero );
ENDIF;
ViewCreate( sCubeCible, sVueZero , nDebug );


# Création des sous-ensembles des dimensions du cube

#Exemple de selection d'un élément dans la dimension
# NomDimCible1
SubsetDestroy ( sDimCible1 , sSubsetZero ) ;
SubsetCreate ( sDimCible1 , sSubsetZero , nDebug ) ; 
SubsetElementInsert ( sDimCible1 , sSubsetZero , 'ElementDimensionCible1' , nDebug ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible1 , sSubsetZero ) ; 

# Exemple de selection de tous les niveaux 0 d'une dimension
# NomDimCible2
SubsetDestroy ( sDimCible2 , sSubsetZero ) ; 
StringMDX = '{TM1FILTERBYLEVEL ( { TM1SUBSETALL ( [ '| NomDimCible2 | ' ] ) } , 0 ) }'
SubsetCreateByMDX ( sSubsetZero , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible2 , sSubsetZero ) ; 

#  Exemple de selection de tous les niveaux 0 d'une dimension excepté un élément
# NomDimCible3
sElementExcepte = 'Nom de l'element que vous souhaitez retirer' ;
SubsetDestroy ( sDimCible3 , sSubsetZero ) ; 
StringMDX = '{ EXCEPT( {TM1FILTERBYLEVEL( {TM1SUBSETALL( [ '| NomDimCible3 |' ] )}, 0)}, { ['| NomDimCible3 |'].['| sElementExcepte |'] }) }' ;
SubsetCreateByMDX ( sSubsetZero , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible3 , sSubsetZero ) ; 

# Exemple de selection des enfant d'un element
# NomDimCible4
sElementParent = 'Nom du parent des elements que vous souhaitez selectionner' ;
SubsetDestroy ( sDimCible4 , sSubsetZero ) ; 
StringMDX = '{TM1DRILLDOWNMEMBER( {TM1FILTERBYPATTERN( {TM1SUBSETALL( [ '| NomDimCible4 |' ] )}, "' | sElementParent | '*")}, ALL, RECURSIVE )}' ;
SubsetCreateByMDX ( sSubsetZero , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible4 , sSubsetZero ) ; 

# Exemple de selection d'element selon un attribut
# NomDimCible5
sAttribut = 'Nom de l'attribut' ;
sNomAttribut = 'Nom de l'element de l'attribut a rechercher' ;
SubsetDestroy ( sDimCible5 , sSubsetZero ) ;
StringMDX = '{FILTER( {TM1SUBSETALL( [ '| NomDimCible5 |' ] )}, [ '| NomDimCible5 |' ].[ '| sAttribut |' ] = "' | sNomAttribut | '")}' ;
SubsetCreateByMDX ( sSubsetZero , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible5 , sSubsetZero ) ; 

#Exemple de creation de ss ensemble avec une boucle
# NomDim6
SubsetDestroy ( sDimCible6 , sSubsetZero ) ; 
SubsetCreate ( sDimCible6 , sSubsetZero , nDebug  ) ;

# Exemple boucle selon l'attribut d'un element
# Récuperer un attribut => par le cube de controle pour une question de performance
sCubeAttr = '}ElementAttributes_' | 'NomDimAttr' ;

i = 1 ;

nTailleBoucle = Dimsiz ( 'NomDimCible6' ) ;

WHILE ( nTailleBoucle >= i ) ;

  sElement = DIMNM ( 'NomDimCible6' , i ) ;

  IF ( ELLEV ( 'NomDimCible6' , sElement ) = 0 & CellGetS ( sCubeAttr , 'NomDimAttr' , 'NomAttribut' ) = 'ATTRIBUTCHOISI' ; ) ;

  SubsetElementInsert ( sDimCible6 , sSubsetZero , sElement , nDebug ) ;

  ENDIF;

  i = i + 1 ;

END;

ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible6 , sSubsetZero ) ; 

# NomDimMesure
SubsetDestroy ( sDim , sSubsetZero ) ; 
StringMDX = '{TM1FILTERBYLEVEL ( { TM1SUBSETALL ( [ '| NomDimCible | ' ] ) } , 0 ) }'
SubsetCreateByMDX ( sSubsetZero , StringMDX , nDebug  ) ;
ViewSubsetAssign ( sCubeCible , sVueZero , sDimCible , sSubsetZero ) ; 

# RAZ de la vue zero
ViewZeroOut( sCubeCible, sVueZero );

###############################  FIN CREATION VUE ZERO ############################

#endregion
#region Metadata

#****Begin: Generated Statements***
#****End: Generated Statements****


###################  CONTROLE EXISTENCE ELEMENT DANS DIM  #################

IF ( DIMIX ( 'NOMDIM' , 'ELEMENT' ) = 0 );
  nErrors = 1;
  ExecuteProcess( 'Process_Log_Create', 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'METADATA' , 'pStatus' , 'FATAL' , 'pRef' , nErrors ,
  'pV1' , 'L' | CHAR(39) | 'element ' | 'ELEMENT' | ' n' | CHAR (39) | 'existe pas dans la dimension ' | 'NOMDIM' ) ;
  ProcessBreak ;
ENDIF ;

################### FIN CONTROLE EXISTENCE ELEMENT DANS DIM  #################



###################  POUR CONSTRUCTION DE DIM  #################

DimensionElementInsert ( 'NOMDIM' , 'ELEMENT' ) ;

DimensionDeleteAllElements ( 'NOMDIM' ) ;

DimensionElementComponentAdd ( 'NOMDIM' , 'ELEMENTPARENT' , 'ELEMENTENFANT' , 'PONDERATION' ) ;

###################  FIN POUR CONSTRUCTION DE DIM  #################





#endregion
#region Data

#****Begin: Generated Statements***
#****End: Generated Statements****

###############################   EXEMPLE BOUCLE DIM #################################

# Boucler sur une dimension

i = 1 ;

nTailleBoucle = Dimsiz ( 'NomDimBoucle' ) ;

WHILE ( nTailleBoucle >= i ) ;

  sElement = DIMNM ( 'NomDimElement' , i ) ;

  IF ( ELLEV ( 'NomDimElement' , sElement ) = 0 ) ;

  # Traitement de la boucle voulu

  ENDIF;

  i = i + 1 ;

END;

###############################   FIN EXEMPLE BOUCLE DIM #################################


###############################   EXEMPLE BOUCLE SS ENSEMBLE #################################

# Boucler sur un ss ensemble

i = 1 ;

sSubName = 'NomSsEnsemble' ;
nTailleBoucle = SubsetGetSize ( 'NomDimSsEnsemble' , sSubName ) ;

WHILE ( nTailleBoucle >= i ) ;

  sElement = SubsetGetElementName ( 'NomDimSsEnsemble' , sSubName , i ) ;

  IF ( ELLEV ( 'NomDimElement' , sElement ) = 0 ) ;

  # Traitement de la boucle voulu

  ENDIF;

  i = i + 1 ;

END;

###############################   FIN EXEMPLE BOUCLE SS ENSEMBLE #################################




###############################   RECUPERATION ATTRIBUT #################################

# Récuperer un attribut => par le cube de controle pour une question de performance
sCubeAttr = '}ElementAttributes_' | 'NomDimAttr' ;

CellGetS ( sCubeAttr , 'NomDimAttr' , 'NomAttribut' ) ;
CellGetN ( sCubeAttr , 'NomDimAttr' , 'NomAttribut' ) ;

###############################  FIN RECUPERATION ATTRIBUT ###############################



###############################  PASSAGE D'UNE DIM CONSO A UNE DIM A PLAT   #################################

# Script permettant de simuler une consolidation de données sur une dimension à plat
# => Ici la dimension 'NomDim1' est une hierarchie consolidée et 'NomDim2' 
# est à plat. Les éléments dans les 2 dimensions sont les mêmes sauf que dans 'NomDim2' 
# tous est à plat. Cela permet en comparant en fonction du parent de 'NomDim1' de simuler la consolidation
# dans la dimension 'NomDim2' 

elParent = ELPAR( 'NomDim1' , VariableDim , 1);

WHILE ( DIMIX ( 'NomDim1' , elParent) > 0);

  IF ( DIMIX( 'NomDim2' , elParent ) > 0 );
    #Traitement voulu exemple CellPut
  ENDIF;

  elParent = ELPAR( 'NomDim1' , elParent , 1);

END;

############################### FIN PASSAGE D'UNE DIM CONSO A UNE DIM A PLAT   #################################
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

###############################   MONITORING    #################################

# Désactivation du logging -> Réactivation en Epilog
vLogChanges = CubeGetLogChanges( sCubeCible );
CubeSetLogChanges( sCubeCible , 1 );

#__________________________________________________________________________________________
#
#                                 Contrôle des erreurs                                            
#__________________________________________________________________________________________

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'END' ) ;

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , If ( GetProcessErrorFilename @= '' , 'OK' , 'KO' ) ,
	'pV1' , 'Process exécuté en ' , 'pV2' , cUtilisateur ) ;

ExecuteProcess( 'Process_Log_Create' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess , 'pNumero' , zLogNumero , 'pType' , 'LOG' , 'pStatus' , 'BYE' ) ;
	
#__________________________________________________________________________________________
#
#                                 Création des fichiers de suivi depuis le cube Processes_Log et envoi email                         
#__________________________________________________________________________________________

	
ExecuteProcess( 'Process_Log_Export' , 'pProcesses' , cMainProcName , 'pDateExec' , cTimeProcess ) ;

#__________________________________________________________________________________________
#
#                                 zZIP_AND_CLEAN                                                                    
#__________________________________________________________________________________________

# Repertoire de localisation des executables
cRepertoireExe = CellGetS(sCubeParamT , 'Txt_RepertoireExe', 'ValeurS' ) ;

# Repertoire de localisation des archives à creer
sRepCible = CellGetS(sCubeParamT , 'Txt_RepertoireArchive', 'ValeurS' ) ;

# Repertoire de localisation des Logs
sRepLogs = GetProcessErrorFileDirectory ;

# Fichier de log
sLogFileError = cMainProcName | '_' | cUtilisateur | '_' | cTimeProcess | '.log' ;

### Execution du Zip And Clean ####
ExecuteProcess( 'zZip_And_Clean', 'pRepertoireExe', cRepertoireExe, 'pRepertoireDataSource' , sSource | '\' ,'pNomEtExtensionFichierSource', sNomFichier ,
    'pRepertoireDataLog', cRepertoireRacine, 'pNomEtExtensionFichierLog' ,  sLogFileError ,
    'pRepertoireDestinationArchive',  sRepCible, 'pProcessName', cMainProcName, 'pSuppFichierSource', '0' ) ;


IF ( nErrors > 0 ) ;
  ProcessQuit();
ENDIF ;

###############################  FIN MONITORING    #################################
#endregion