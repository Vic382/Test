#region Prolog

#****Begin: Generated Statements***
#****End: Generated Statements****

#***********************************************************************************************
# CREATEUR : CTY
# DATE DE CREATION : 17/11/2023
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : 
# DESCRIPTION DU PROCESSUS : Ajout manuel d'un élément dans la dimension Immobilisation
# 
#************************************************************************************************

###############################   MONITORING   #################################

### 0.Définition des variables du monitoring
Z_DEBUT_EXE =  StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
sCubeParamS	             = 'ParametresSources' ;
sCubeParamT	             = 'ParametrageT' ;
cMainProcName       = GetProcessName();
cRepertoireRacine   = GetProcessErrorFileDirectory;
cTimeStamp          = TimSt( Now, '\Y\m\d\h\i\s' );
cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));
cTimeProcess        = cTimeStamp | '_' | cRandomInt;
sSource = '' ;
sNomFichier =  '' ;
nErrors = 0 ;
nErrorsSource = 0 ; 
zLogNumero         = 1 ;
nErrors          = 0;
vMessage              = '';

IF ( SUBST ( TM1User() , 1 , 2 ) @= 'R*' ) ;
	cUtilisateur = 'Admin' ;
ELSE ;
	cUtilisateur        = TM1User();
ENDIF ;

### 1. Déclaration des variables

# Pour suppression des vues et ss ensemble temporaire
nDebug = 1 ; 

#**Fichier Debug
sFichierRepDebug = CellGetS ( sCubeParamT , 'Txt_RepertoireDebug' , 'ValeurS' );
sDebug = sFichierRepDebug | 'test'|cMainProcName|'.txt' ;

sExerciceEnCours = DimensionElementPrincipalName ( 'Exercice' , CellGetS( 'ParametresFonctionnels', 'ExerciceEnCours' , 'ValeurS' ));
sVersionEnCours = DimensionElementPrincipalName ( 'Version' , CellGetS( 'ParametresFonctionnels', 'VersionEnCours' , 'ValeurS' ));
sScenarioEnCours = DimensionElementPrincipalName ( 'Scenario' , CellGetS( 'ParametresFonctionnels', 'ScenarioEnCours' , 'ValeurS' ));

# Pas de création d'immobilisation sur le réel puisque les immobilisations sont fictives
IF (sScenarioEnCours @= 'Reel');
    sMessage = 'Impossible de créer une immobilisation sur le scénario réel'; 
    ItemReject( sMessage );
    ProcessBreak;
ENDIF;    

###############################   FIN MONITORING   #################################

# Recomposition de la date d'ouverture magasin format DayNo (YYYY-MM-DD)
sDateOuverture = ATTRS( 'Magasin', pMagasin, 'Date_Ouverture' );
sJourOuverture = SUBST(sDateOuverture, 1, 2 );
sMoisOuverture = SUBST(sDateOuverture, 4, 2 );
sAnneeOuverture = SUBST(sDateOuverture, 7, 4 );
nDateOuverture = DayNo(sAnneeOuverture | '-' | sMoisOuverture | '-' | sJourOuverture) ;

# Contrôle que l'immo ne puisse pas être ajoutée avant la date d'ouverture du magasin
nDateDebut = DayNo( pDateDebut ) ;
IF ( nDateDebut < nDateOuverture ) ;
  sMessage = 'Impossible d"ajouter une immobilisation avant la date d"ouverture du magasin' ;
  ItemReject( sMessage );
  ProcessBreak ;
ENDIF ;

# Création d'une matricule pour l'immo fictive : AAA-F-Libelle_01
sDimImmo = 'Immobilisation' ;
sMagasinTrigram = ATTRS( 'Magasin', pMagasin, 'Trigram' ) ;
sCodeImmo = sMagasinTrigram | '-F-' | pLibelle |'_'| '01' ;

# Si le code est libre, on ajoute l'immo avec compteur 01
IF(DIMIX( sDimImmo, sCodeImmo ) = 0);
    DimensionElementInsertDirect( sDimImmo, '', sCodeImmo, 'N' );
    DimensionElementComponentAddDirect( sDimImmo, 'Total_Immobilisation', sCodeImmo, 1 );

# Si le code n'est pas disponible, on incrémente le compteur de fin (AAA-F-CAISSON_METIER_01 -> AAA-F-CAISSON_METIER_02)
ELSE;
   
   # Boucle sur toute la dim Immo 
   nTailleBoucle = DIMSIZ( sDimImmo );
   i = 1; 

   WHILE( i <= nTailleBoucle);
      
      # Variables concernant l'immo parcourue (AAA-F-CAISSON_METIER_01)
      sImmo = DIMNM( sDimImmo, i );
      
      sMagasinTrigramImmo = SUBST(sImmo, 1, 3);
      sFictif = SUBST(sImmo, 5, 1);
      nLong = LONG (sImmo);
      nLibLong = LONG(sImmo) - 9;
      sLib = SUBST(sImmo, 7, nLibLong);

      nCompteurMax = 1;
      
      #ASCIIOutput( '..\DEBUG\Immo_Ajout.csv', sImmo, sMagasinTrigramImmo, sFictif , sLib );

      IF (sMagasinTrigramImmo @= sMagasinTrigram );
        IF(sFictif @= 'F');
          sCompteur = SUBST(sImmo, nLong - 1, 2);
          nCompteur = StringToNumber (sCompteur);
          IF(sLib @= pLibelle);
             IF (nCompteur > nCompteurMax);
               nCompteurMax = nCompteur;             
             ENDIF;  
          ENDIF;
        ENDIF;
      ENDIF;
      i = i + 1; 
   END;
   
   # Recomposition du nouveau compteur
   sCompteurMax = NumberToString( nCompteurMax + 1 );
   IF(LONG(sCompteurMax)=1);
      sCompteurMax = '0' | sCompteurMax ;
   ELSE;
      sCompteurMax = sCompteurMax ; 
   ENDIF;
   
   # Recomposition du code immo final
   sCodeImmo = sMagasinTrigram | '-F-' | pLibelle |'_'| sCompteurMax ;

   # Ajout de l'immo 
   DimensionElementInsertDirect( sDimImmo, '', sCodeImmo, 'N' );
   DimensionElementComponentAddDirect( sDimImmo, 'Total_Immobilisation', sCodeImmo, 1 );
ENDIF;
#endregion
#region Epilog

#****Begin: Generated Statements***
#****End: Generated Statements****

IF (sScenarioEnCours @= 'Reel');
    sMessage = 'Impossible de créer une immobilisation sur le scénario réel'; 
    ItemReject( sMessage );
    ProcessBreak;
ENDIF;  


sMagasin = DimensionElementPrincipalName ( 'Magasin' , pMagasin );

IF(sCompteurMax @= '');
  sAlias = pMagasin | ' - ' | sMagasinTrigram | '-F-' | pLibelle |'_01'  ;
ELSE;
  sAlias = pMagasin | ' - ' | sMagasinTrigram | '-F-' | pLibelle |'_'| sCompteurMax  ; 
ENDIF;

# Calcul de la date de fin à partir de pDateDebut (pickliste format YYYY-MM-DD)
nDateDebut = DayNo( pDateDebut );
nDateFin = nDateDebut + (pDuree * 365) ;
sDateFin = Date( nDateFin , 1 );

# Alimentation des attributs dans la dimension Immobilisation
AttrPutS( pDateDebut , sDimImmo , sCodeImmo , 'Date_Debut' );
AttrPutS( sDateFin , sDimImmo , sCodeImmo , 'Date_Fin' );
AttrPutS( sMagasin , sDimImmo , sCodeImmo , 'Magasin' );
AttrPutS( sAlias , sDimImmo , sCodeImmo , 'Alias' );
AttrPutS( pLibelle, sDimImmo, sCodeImmo, 'Libelle' );
AttrPutS( 'FICTIF', sDimImmo, sCodeImmo, 'Fictif' );
AttrPutS( 'Manuelle', sDimImmo, sCodeImmo, 'Creation' );
AttrPutS( pRepartition, sDimImmo, sCodeImmo, 'Repartition' );
AttrPutN( pDuree , sDimImmo , sCodeImmo , 'Duree' );
AttrPutN( pMontant , sDimImmo , sCodeImmo , 'Montant_Initial' );

# Alimentation du cube Investissement_Saisie
sCubeSaisie = 'Investissement_Saisie';
CellPutN( pMontant,   sCubeSaisie, sExerciceEnCours, sVersionEnCours, sScenarioEnCours, sCodeImmo, sMagasin, 'Cout_Immo' );
CellPutN( pDuree,     sCubeSaisie, sExerciceEnCours, sVersionEnCours, sScenarioEnCours, sCodeImmo, sMagasin, 'Duree_Amortissement' );
CellPutS( pDateDebut, sCubeSaisie, sExerciceEnCours, sVersionEnCours, sScenarioEnCours, sCodeImmo, sMagasin, 'Date_Debut' );
CellPutS( sDateFin,   sCubeSaisie, sExerciceEnCours, sVersionEnCours, sScenarioEnCours, sCodeImmo, sMagasin, 'Date_Fin' );


#------------------------------------------------ MONITORING  ------------------------------------------------#

# Declaration variables et constantes

Z_FIN_EXE =  StringToNumber(TimSt (Now, '\h'))*3600 +StringToNumber(TimSt (Now, '\i'))*60+StringToNumber(TimSt (Now, '\s'));
Z_PERIODE=subst(TODAY(1),1,4) | subst(TODAY(1),6,2);

Z_STATUS=IF(GetProcessErrorFilename@='','OK','KO');
Z_TEMPS_EXECUTION= Z_FIN_EXE - Z_DEBUT_EXE;
# HEURE D'EXECUTION
nNewFormatId  =  NewDateFormatter ( 'fr-FR' , 'Europe/Paris' , 'serial' , 'medium' , 'datetime' );
Z_LOCAL_TIME = FormatDate ( NOW () , 'yyyy-MM-dd H:mm' , nNewFormatId );
Z_UTILISATEUR = TM1User;

# Ecriture des informations sur le processus dans le cube ParametresSources                       

nDebut= SCAN( 'pans:u:', Z_UTILISATEUR );
nDebutLong = LONG('pans:u:');
nStart = nDebut + nDebutLong ;
nTotal = LONG(Z_UTILISATEUR) ;
Z_UTILISATEUR = SUBST(Z_UTILISATEUR, nStart, nTotal - nStart - 1) ;

CELLPUTS( Z_STATUS , sCubeParamS , cMainProcName , 'Statut' );
CELLPUTN( Z_TEMPS_EXECUTION , sCubeParamS ,  cMainProcName ,'TempsExe');
CELLPUTS( Z_LOCAL_TIME, sCubeParamS , cMainProcName ,'DernExe');
CELLPUTS( Z_UTILISATEUR, sCubeParamS , cMainProcName ,'txt_Utilisateur' );

#------------------------------------------------ FIN - MONITORING  ------------------------------------------------#
#endregion