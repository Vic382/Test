#region Prolog
#****Begin: Generated Statements***
#****End: Generated Statements****

#*****************************************************************************
# CREATEUR : 
# DATE DE CREATION : ../../201.
# DERNIERE MODIFICATION EFFECTUEE PAR : 
# DATE DE DERNIERE MODIFICATION : ../../2018
# DESCRIPTION DU PROCESSUS : 
# Mise à jour de la dimension "CLIENT"
#*****************************************************************************

# Définition de la variable "sDim" : à chaque fois que l'on citera "sDim", on fera référence à "Client" ;
sDim = 'Client' ;

# Test de l'existence de la dimension "Client" 
# Si elle n'existe pas, on la créé.
# Si elle existe, on la remet la vide pour la réalimenter.
# Les données stockées sur des éléments qui n'existeront pas après l'alimentation de la dimension seront perdues.
If ( DimensionExists ( sDim ) = 0 ) ;
	DimensionCreate ( sDim ) ; 
Else ; 
	DimensionDeleteAllElements ( sDim ) ; 
EndIf ; 


# Création de l'élément consolidé "Total_Client"; 
DimensionElementInsert ( sDim , '' , 'Total_Client' , 'C' ) ; 

# Les attributs :
# Remise à zéro de tous les attributs de la diemsnion :
# Le libellé long : il s'agit du code de l'élément concaténé avec son nom
AttrDelete ( sDim , 'LibelleLong' ) ;
AttrInsert ( sDim , '' , 'LibelleLong' , 'A' ) ; 
# Le libellé court
AttrDelete ( sDim , 'LibelleCourt' ) ;
AttrInsert ( sDim , '' , 'LibelleCourt' , 'A' ) ; 
# Le pays
AttrDelete ( sDim , 'Pays' ) ;
AttrInsert ( sDim , '' , 'Pays' , 'S' ) ; 

# Création d'un ordre de tri par défaut pour la dimension :
DimensionSortOrder ( sDim , 'ByInput' , 'Ascending' , 'ByHierarchy' , 'Ascending' ) ; 

# Définition de la source du processus
# 1 - Définition du chemin du dossier dans lequel le fichier source se situe
sCheminDossier = 'D:\IBM\Instances\FORMATION\SOURCES\' ;
# 2 - Définition du nom du fichier source
sNomFichier = 'CLIENTS.csv' ;
# 3 - Le fichier à récupérer est la concatenation du chemin du fichier et du fichier :
sFichier = sCheminDossier | sNomFichier ; 

# Définition de la source du processu : il s'agit du # 3 : la variable sFichier
DataSourceNameForServer  = sFichier ; 
#endregion
#region Metadata
#****Begin: Generated Statements***
#****End: Generated Statements****

# Ajout des éléments dans la dimension :
# Le code client
DimensionElementInsert ( sDim , '' , CodeClient , 'N' ) ; 
# Le code de regroupement 1
DimensionElementInsert ( sDim , '', CodeRegroupement1 , 'C' ) ;
# Le code de regroupement 2
DimensionElementInsert ( sDim , '' , CodeRegroupement2 , 'C' ) ;

# Mise à jour des consolidations : 
# CodeClient dans CodeRegroupement1
DimensionElementComponentAdd ( sDim , CodeRegroupement1 , CodeClient , 1)  ;
# CodeRegroupement1 dans CodeRegroupement2
DimensionElementComponentAdd ( sDim , CodeRegroupement2 , CodeRegroupement1 , 1 ) ;
# CodeRegroupement2 dans Total_Client
DimensionElementComponentAdd ( sDim , 'Total_Client' , CodeRegroupement2 , 1 ) ; 
 
#endregion
#region Data
#****Begin: Generated Statements***
#****End: Generated Statements****
# Alimentation des attributs : 
sLibelleCourt = LibelleClient ; 
sLibelleLong = CodeClient | ' - ' | LibelleClient ;

AttrPutS ( sLibelleCourt , sDim , CodeClient , 'LibelleCourt' ) ; 
AttrPutS ( sLibelleLong , sDim , CodeClient , 'LibelleLong' ) ;
AttrPutS ( AttrPays , sDim , CodeClient , 'Pays' ) ; 

sLibelleCourtReg1 = LibelleRegroupement1  ;
sLibelleLongReg1 = CodeRegroupement1 | ' - ' | LibelleRegroupement1 ;
AttrPutS ( sLibelleCourtReg1 , sDim , CodeRegroupement1 , 'LibelleCourt' ) ; 
AttrPutS ( sLibelleLongReg1 , sDim , CodeRegroupement1 , 'LibelleLong' ) ; 



sLibelleCourtReg2 = LibelleRegroupement2 ; 
sLibelleLongReg2 = CodeRegroupement2 | ' - ' | LibelleRegroupement2 ; 
AttrPutS ( sLibelleCourtReg2 , sDim , CodeRegroupement2 , 'LibelleCourt' ) ; 
AttrPutS ( sLibelleLongReg2 , sDim , CodeRegroupement2 , 'LibelleLong' ) ; #Section Epilogue
#****Begin: Generated Statements***
#****End: Generated Statements****
#test
#endregion